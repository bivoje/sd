#!/bin/bash

# this is a tester module for sd

# conventions
# get..    name denotes functions which
#          put value to stdout
# set..    name denotes functions which
#          set the global variable
# set..i   name denotes functions which
#          will set if variable not previously set
# argn     function - which actually alias -
#          checks proper number of argument was given
# assert   same as ASSERT macro in C language
#          mute on un-debugging not supported
#          use with string of statement to evaluate

# exporting variables
# { SOURCENAME
# , EXECNAME
# , TESTIONAME
# , CMPLNEED
#     0 doesn't needed
#     1 exec not exist
#     2 src modified
#     3 exec has created manually
# , TESTIS
# , TESTOS
# }

shopt -s expand_aliases
alias argn='_argn $0 $LINENO $#'
alias assert='_assert $0 $LINENO'

function _argn {
  if [ $# != 4 ]; then
    echo ARGNERROR! on $2 th line of \"$1\"
    if [ $# == 3 ]; then
      echo Too little arguments
    else echo Too many arguments; fi
    exit
  elif [ $3 != $4 ]; then
    echo ARGERROR! on $2 th line of \"$1\"
    echo required $4 but given $3
    exit
  fi
}

function _assert {
  if [ $# != 3 ]; then
    echo ASSERTERROR! on $2 th line of \"$1\"
    if [ $# == 2 ]; then
      echo Too little arguments
    else echo Too many arguments; fi
    exit
  elif ! [ $3 ]; then
    echo ASSERTION FAILED! on $2 th line of \"$1\"
    echo of assertion \"$3\"
    exit
  fi
}

function getsrcmoddate {
echo ""
#TODO
}

function getexecmoddate {
echo ""
#TODO
}

function uptsrcmoddate {
echo ""
#TODO
}

function upexecmoddate {
echo ""
#TODO
}

function getextension {
  argn 1

  echo $1 | rev | cut -s -d '.' -f 1 | rev
}

function setsrcexecnamei {
  argn 0

  # if variable already not set
  SOURCENAME=${SOURCENAME:-main.c}
  EXECNAME=${EXECNAME:-main}
}

function getcmplcmdfromext {
  argn 1

  local cmplcmd=
  local ext=$1
  local map=(
    "c   gcc $SOURCENAME -o $EXECNAME"
    "cpp gcc $SOURCENAME -o $EXECNAME"
    "hs  ghc $SOURCENAME -o $EXECNAME"
    "lhs ghc $SOURCENAME -o $EXECNAME"
    "sh  cp $SOURCENAME $EXECNAME && chmod u+x $EXECNAME"
    )

  for val in "${map[@]}"; do
    if [ `echo $val | cut -s -d ' ' -f 1` == $ext ]; then
      cmplcmd=`expr "$val" : "$ext[[:blank:]]\+\(.*\)"`
      break
    fi
  done

  echo $cmplcmd
}

function setcmplcmdi { #src name
  argn 0

  local ext=`getextension $SOURCENAME`
  local ncmplcmd=`getcmplcmdfromext $ext`
  CMPLCMD=${CMPLCMD:-$ncmplcmd}
}

function setcmplneed { # src,exec name
  argn 0

  local srcmoddate=
  local osrcmoddate=
  local execmoddate=
  local oexecmoddate=

  if ! [ -e $EXECNAME ]; then
    CMPLNEED=1
  else
    srcmoddate=`stat $SOURCENAME -c %y`
    osrcmoddate=`getsrcmoddate`
    if [ "$srcmoddate" != "$osrcmoddate" ]; then
      CMPLNEED=2
    else
      execmoddate=`stat $EXECNAME -c %y`
      oexecmoddate=`getexecmoddate`
      # user might have compiled by him/herself
      if [ "$execmoddate" != "$oexecmoddate" ]; then
        CMPLNEED=3
      else
        CMPLNEED=0
      fi
    fi
  fi
}

function settestios { # testioname
  argn 0

  local wheio=0 # parsing on input(-1), comment(0), output(1)
  local wheiof=0 # explicit 0, successive 1
  local lineno=0 # for error reporting
  local readnum=0
  local error=0
  TESTIONUM=0 # used as index of TESTIS, TESTOS in the loop
  # erasing previouse variables
  TESTIS[0]=
  TESTOS[0]=

  while read line; do
    ((lineno++))
    case $wheio in
      0 ) # comment
        if [[ "$line" =~ ^==+ ]]; then
          wheio=-1
          readnum=`expr "$line" : "^==\+\([[:digit:]]\+\)$"`
          if [ -z $num ]; then readnum=0; fi
        fi
        ;;
      -1 ) # input
        if [ $readnum != 0 ]; then
          TESTIS[$TESTIONUM]+="\n$line"
          ((readnum--))
        elif [[ "$line" =~ ^==+ ]]; then
          # if what we read was known to be successive
          # they were actually all comments
          if [ $wheiof == 1 ]; then
            # now it's explicit
            wheiof=0
            TESTIS[$TESTIONUM]=
            wheio=-1
            readnum=`expr "$line" : "^--\+\([[:digit:]]\+\)$"`
            if [ -z $readnum ]; then readnum=0; fi
          else # if what we read was explicit
            # repeated =====
            error=1
          fi
        elif [[ "$line" =~ ^--+ ]]; then
          wheio=1
          readnum=`expr "$line" : "^--\+\([[:digit:]]\+\)$"`
          if [ -z $num ]; then readnum=0; fi
        else
          TESTIS[$TESTIONUM]+="\n$line"
        fi
          ;;
      1 ) # output
        if [ $readnum != 0 ]; then
          TESTOS[$TESTIONUM]+="\n$line"
          ((readnum--))
        elif [[ "$line" =~ ^==+ ]]; then
          ((TESTIONUM++))
          # erasing previouse variables
          TESTIS[$TESTIONUM]=
          TESTOS[$TESTIONUM]=
          wheio=-1
          wheiof=1
          readnum=`expr "$line" : "^==\+\([[:digit:]]\+\)$"`
          if [ -z $readnum ]; then readnum=0; fi
        elif [[ "$line" =~ ^--+ ]]; then
          # repeated -----
          error=1
        else
          TESTOS[$TESTIONUM]+="\n$line"
        fi
        ;;
    esac
    if [ $error != 0 ]; then break; fi
  done < $TESTIONAME


  # if last lines were comments
  if [ $wheio == -1 -a $wheiof == 1 ]; then
    TESTIS[$TESTIONUM]=""
    ((TESTIONUM--))
  fi

  # index number -> length of array
  ((TESTIONUM++))

  #if [ $error != 0 ]; then false;
  #  # wheio should be -1 (input) when it's end
  # else [ $wheio != -1 ]; fi
  if [ $error != 0 ] || [ $wheio == -1 -a $wheiof == 0 ]; then
    return $lineno
  else # parsed successfully
    # eliminate leading newline
    for i in `seq $TESTIONUM`; do
      TESTIS[$[i-1]]=${TESTIS[$[i-1]]:2}
      TESTOS[$[i-1]]=${TESTOS[$[i-1]]:2}
    done
    return 0
  fi
}

function compile { # cmplcmd
  argn 0

  echo $CMPLCMD
  $CMPLCMD
}

function testing { # [auto]compile, settestios
  argn 0

  local testos=
  local clmwidth=20

  for i in `seq 0 $[TESTIONUM-1]`; do
    testos="`echo -e ${TESTIS[$i]} | ./$EXECNAME`"

    diferr=`diff -y --width=$clmwidth \
                 <(echo -e "${TESTOS[$i]}") \
                 <(echo -e "$testos")`

    if [ $? != 0 ]; then
      echo === ERROR for input $[i+1] !!
      echo "$diferr"
    fi
  done
}

function autotesting { # testioname
  argn 0

  if ! settestios; then
    echo error on your iofile at line:$?
  else
    testing
  fi
}

function autocompile { # src/exec name
  argn 0

  setcmplneed
  #CHECKME
  if [ $CMPLNEED == 3 ]; then
    echo you have executable compiled manually!
    while true; do
      read -p "would you compile it again with sd? \(y or n\)" ans
      case $ans in
        [Yy]* ) setcmplcmdi; compile; break;;
        [Nn]* ) break;;
        *     ) echo please answer y or n;;
      esac
    done

  elif [ $CMPLNEED != 0 ]; then
    setcmplcmdi
    compile
  fi
}
