#!/bin/bash

# this is a tester module for sd

# conventions
# names  | denotes functions which
# -------|--------------------------
# get..    echos value to stdout
# set..    set the global variable
# [x]_..   returns meaningful value
#  x=b      boolean success
#  x=v      result value
# __..     used for macros
# else     user-interaction routines.
#   auto..   frontend routines.

# debug utilities..
# argn     function - which actually alias -
#          checks proper number of argument was given
# assert   same as ASSERT macro in C language
#          mute on un-debugging not supported
#          use with string of statement to evaluate

# exporting variables
# { SOURCENAME
# , EXECNAME
# , TESTIONAME
# , CMPLNEED
#     0 doesn't needed
#     1 exec not exist
#     2 src modified
#     3 exec has created manually
# , TESTIS
# , TESTOS
# , WKDIR -- guarantee following structure
#     /snap
#     fig
# }

shopt -s expand_aliases
alias argn='__argn $0 $LINENO $#'
alias assert='__assert $0 $LINENO'

WKDIR=.sd

function __argn {
  if [ $# != 4 ]; then
    echo ARGNERROR! on $2 th line of \"$1\"
    if [ $# == 3 ]; then
      echo Too little arguments
    else echo Too many arguments; fi
    exit
  elif [ $3 != $4 ]; then
    echo ARGERROR! on $2 th line of \"$1\"
    echo required $4 but given $3
    exit
  fi
}

function __assert {
  if [ $# != 3 ]; then
    echo ASSERTERROR! on $2 th line of \"$1\"
    if [ $# == 2 ]; then
      echo Too little arguments
    else echo Too many arguments; fi
    exit
  elif ! [ $3 ]; then
    echo ASSERTION FAILED! on $2 th line of \"$1\"
    echo of assertion \"$3\"
    exit
  fi
}

function set_fig { # wkdir
  argn 2

  local num=`grep $WKDIR/fig -e "^$1=" -c`

  if [ $num == 1 ]; then
    sed "s/^$1=.*$/$1=$2/" $WKDIR/fig > $WKDIR/fig.m
    mv $WKDIR/fig.m $WKDIR/fig
  elif [ $num == 0 ]; then
    echo "$1=$2" >> $WKDIR/fig
  else
    echo duplicated fig \"$1\" apeared!
  fi
}

function get_fig { # wkdir
  local line=`grep $WKDIR/fig -e "^$1"`
  expr "$line" : "^$1=\(.*\)$"
}

function b_ismodified { # wkdir
  argn 1

  # diff will return 2 if there's no such file
  diff $1 $WKDIR/snap/$1 &> /dev/null
  return $?
}

function upmodstate { # wkdir
  argn 1

  cp $1 $WKDIR/snap/$1
}

# echos nothing on failure
function getextension {
  argn 1

  echo $1 | rev | cut -s -d '.' -f 1 | rev
}

function setsrcexecnamei {
  argn 0

  # if variable already not set
  SOURCENAME=${SOURCENAME:-main.c}
  EXECNAME=${EXECNAME:-main}
}

function getcmplcmdfromext {
  argn 1

  local cmplcmd=
  local ext=$1
  local map=(
    "c   gcc $SOURCENAME -o $EXECNAME"
    "cpp g++ $SOURCENAME -o $EXECNAME"
    "hs  ghc $SOURCENAME -o $EXECNAME"
    "lhs ghc $SOURCENAME -o $EXECNAME"
    "sh  cp $SOURCENAME $EXECNAME && chmod u+x $EXECNAME"
    )

  for val in "${map[@]}"; do
    if [ `echo $val | cut -s -d ' ' -f 1` == $ext ]; then
      cmplcmd=`expr "$val" : "$ext[[:blank:]]\+\(.*\)"`
      break
    fi
  done

  echo $cmplcmd
}

function setcmplneed { # wkdir, src,exec name
  argn 0

  if ! [ -e $EXECNAME ]; then
    CMPLNEED=1
  else
    if ! b_ismodified $SOURCENAME ; then
      CMPLNEED=2
    else
      # user might have compiled by him/herself
      if ! b_ismodified $EXECNAME ; then
        CMPLNEED=3
      else
        CMPLNEED=0
      fi
    fi
  fi
}

function checktestios {
  echo testionum: $TESTIONUM
  for i in `seq $TESTIONUM`; do
    echo INPUT $i ==============
    echo -e ${TESTIS[$[i-1]]}
    echo OUTPUT $i -------------
    echo -e ${TESTOS[$[i-1]]}
  done
  echo done! =================
}

function v_settestios { # testioname
  argn 0

  local wheio=0 # parsing on input(-1), comment(0), output(1)
  #TODO wheio=-1 this enales ommiting first =====
  local wheiof=0 # explicit 0, successive 1
  local lineno=0 # for error reporting
  local readnum=0
  local error=0
  TESTIONUM=0 # used as index of TESTIS, TESTOS in the loop
  # erasing previouse variables
  TESTIS[0]=
  TESTOS[0]=

  while read line; do
    ((lineno++))
    case $wheio in
      0 ) # comment
        if [[ "$line" =~ ^==+ ]]; then
          wheio=-1
          readnum=`expr "$line" : "^==\+\([[:digit:]]\+\)$"`
          if [ -z $num ]; then readnum=0; fi
        fi
        ;;
      -1 ) # input
        if [ $readnum != 0 ]; then
          TESTIS[$TESTIONUM]+="\n$line"
          ((readnum--))
        elif [[ "$line" =~ ^==+ ]]; then
          # if what we read was known to be successive
          # they were actually all comments
          if [ $wheiof == 1 ]; then
            # now it's explicit
            wheiof=0
            TESTIS[$TESTIONUM]=
            wheio=-1
            readnum=`expr "$line" : "^--\+\([[:digit:]]\+\)$"`
            if [ -z $readnum ]; then readnum=0; fi
          else # if what we read was explicit
            # repeated =====
            error=1
          fi
        elif [[ "$line" =~ ^--+ ]]; then
          wheio=1
          readnum=`expr "$line" : "^--\+\([[:digit:]]\+\)$"`
          if [ -z $num ]; then readnum=0; fi
        else
          TESTIS[$TESTIONUM]+="\n$line"
        fi
          ;;
      1 ) # output
        if [ $readnum != 0 ]; then
          TESTOS[$TESTIONUM]+="\n$line"
          ((readnum--))
        elif [[ "$line" =~ ^==+ ]]; then
          ((TESTIONUM++))
          # erasing previouse variables
          TESTIS[$TESTIONUM]=
          TESTOS[$TESTIONUM]=
          wheio=-1
          wheiof=1
          readnum=`expr "$line" : "^==\+\([[:digit:]]\+\)$"`
          if [ -z $readnum ]; then readnum=0; fi
        elif [[ "$line" =~ ^--+ ]]; then
          # repeated -----
          error=1
        else
          TESTOS[$TESTIONUM]+="\n$line"
        fi
        ;;
    esac
    if [ $error != 0 ]; then break; fi
  done < $TESTIONAME


  # if last lines were comments
  if [ $wheio == -1 -a $wheiof == 1 ]; then
    TESTIS[$TESTIONUM]=""
    ((TESTIONUM--))
  fi

  # index number -> length of array
  ((TESTIONUM++))

  #if [ $error != 0 ]; then false;
  #  # wheio should be -1 (input) when it's end
  # else [ $wheio != -1 ]; fi
  if [ $error != 0 ] || [ $wheio == -1 -a $wheiof == 0 ]; then
    return $lineno # always lineno > 0
  else # parsed successfully
    # eliminate leading newline
    for i in `seq $TESTIONUM`; do
      TESTIS[$[i-1]]=${TESTIS[$[i-1]]:2}
      TESTOS[$[i-1]]=${TESTOS[$[i-1]]:2}
    done
    return 0 # success
  fi
}

function mydiff {
  argn 3

  local width=$1
  local ll1=$2
  local ll2=$3

  success=0

  while [ -n "$ll1" -o -n "$ll2" ]; do
    l1=${ll1%%\\n*}
    ll1=${ll1#*\\n}
    l2=${ll2%%\\n*}
    ll2=${ll2#*\\n}

    if [ "$l1" != "$l2" ]; then
      printf "%-$[width]s" "$l1"
      echo -n '| '
      echo $l2
      success=1
    else
      printf "%-$[width+2]s" "$l1"
      echo $l2
    fi

    [ "$ll1" == "$l1" ] && ll1=""
    [ "$ll2" == "$l2" ] && ll2=""

  done

  return $success
}

#======================================================================
# user-interaction

function b_init_tester {
  argn 0

  if [ -d $WKDIR ]; then
    echo sd repository already exist!
    echo if you want to restart try \"remove\" and then \"init\" again
    return 1
  fi

  if ! mkdir $WKDIR; then return 2; fi
  touch $WKDIR/fig
  mkdir $WKDIR/snap

  srccnds=`ls | grep ".\+\.[a-z]\+$"`
  if [ 1 == `echo $srccnds | wc -l` ]; then
    echo it seems you have only one file in this directory.
    echo -n "do you want to start with \"$srccnds\"? (y/n) "
    read ans
    if [[ "$ans" =~ [yY].* ]]; then
      set_fig SOURCENAME $srccnds
    fi
  fi

  return 0;
}

# vertify later works goes well
# satisfy basic dependence
function v_load_tester {
  argn 0

  if ! [ -d $WKDIR ]; then return 1; fi
  if ! [ -d $WKDIR/snap -o -f $WKDIR/fig ]; then return 2; fi

  # load up variables
  # isn't it (sourcing) dangerous?
  source $WKDIR/fig

  # if variable not set yet
  SOURCENAME=${SOURCENAME:-main.c}
  EXECNAME=`echo $SOURCENAME | sed "s/^\(.\+\)\.[a-z]\+$/\1/"`

  # if variable not set yet
  if [ -z "$CMDLCMD" ]; then
    local ext=`getextension $SOURCENAME`
    CMPLCMD=`getcmplcmdfromext $ext`
    if [ -z "$CMPLCMD" ]; then return 3; fi
  fi

  return 0
  # 0 = success, all works fine!
  # 1 = no WKDIR found
  # 2 = required structure of WKDIR damaged
  # 3 = unrecognizable source file extension.
}

function b_compile { # wkdir, cmplcmd
  argn 0

  echo $CMPLCMD
  $CMPLCMD && upmodstate $EXECNAME && upmodstate $SOURCENAME
  return $?
}

function b_testing { # [auto]compile, settestios
  argn 0

  local testos=
  local clmwidth=20

  for i in `seq 0 $[TESTIONUM-1]`; do
    testos="`echo -e ${TESTIS[$i]} | ./$EXECNAME`"

    diferr=`mydiff $clmwidth "${TESTOS[$i]}" "$testos"`

    if [ $? != 0 ]; then
      echo === ERROR for input $[i+1] !!
      echo "$diferr"
      return 1
    fi
  done

  return 0
}

function b_autotesting {
  argn 0

  if [ -z "$TESTIONAME" ]; then
    echo no iofile yet..
    echo see iofile section of \"sd --help\"
  elif ! v_settestios; then
    echo error on your iofile at line:$?
  else
    b_testing
    return $?
  fi

  return 1
}

function b_autocompile { # src/exec name
  argn 0

  if ! [ -f $SOURCENAME ]; then
    echo "can't find source file \"$SOURCENAME\""
    echo "re-set the correct source name manually"
    echo "using command \"sd set SOURCENAME <sourcename>\""
    return 1
  fi
  setcmplneed
  #CHECKME
  if [ $CMPLNEED == 3 ]; then
    echo you have executable compiled manually!
    while true; do
      read -p "would you compile it again with sd? (y or n)" ans
      case $ans in
        [Yy]* ) return `b_compile` ;;
        [Nn]* ) break;;
        *     ) echo please answer y or n;;
      esac
    done

  elif [ $CMPLNEED != 0 ]; then
    b_compile
    return $?
  fi

  return 0
}
