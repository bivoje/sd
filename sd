#!/bin/bash
# -x for debuging

#<<sd>>

#for Problem coding, Short code, .. etc
#  (coding that needs testing and continueous refactorying)

#globally assumes the system is integral.
#  e.g) all 1~($NVER-1).c files are exist ..



#RULES
## all global variables should be capitalized
## local variables will be lower cases
## for some functions with noting, quiet option will work


#for number checking
REXNUM='^[0-9]+$'

PROG=Main
SUBDIR=.shortc
INPUT=$SUBDIR/.input
OUTPUT=$SUBDIR/.output
VERFIL=$SUBDIR/.version
NVER=0

#REQUIR: file($1) exist
function echolines {
  wc -l $1 | cut -f1 -d " "
}

#REQUIR: file($1) exist
function echobytes {
  wc -c $1 | cut -f1 -d " "
}

function viewachieves { #inte
  ls -al $SUBDIR | grep -e "^d" | rev | cut -f1 -d" " | sed "1,2d" | rev
}

#if any option specified, it will run quietly then report result
function compile { #inte
  if [ -z "$1" ]; then
    echo gcc $PROG.c -o $PROG -O2 -Wall -lm --static -std=c99 -DONLINE_JUDGE
    gcc $PROG.c -o $PROG -O2 -Wall -lm --static -std=c99 -DONLINE_JUDGE
  else
    gcc $PROG.c -o $PROG -O2 -Wall -lm --static -std=c99 -DONLINE_JUDGE 2>/dev/null
    echo $?
  fi
}

#if any option specified, it will run quietly then report result
function cntest { #inte
  touch .tmpout # in case the prog's output is null
  cat $INPUT | ./$PROG > .tmpout
  diffs=$(sdiff $OUTPUT .tmpout)
  diffresult=$?
  if ! [ -z "$1" ]; then
    echo $diffresult
  else
    echo ' '
    if [ 1 == $diffresult ]; then
      echo \<\<\<FAILED!!
      echo $diffs
      CNTEST=0
    elif [ 0 == $diffresult ]; then
      echo \>\>\>SUCCESS!
      cat .tmpout
      CNTEST=1
    fi
    echo ' '
  fi
}

function init {
  if ! [ -e $SUBDIR ]; then
    mkdir $SUBDIR
    echo 1 > $VERFIL
    touch $INPUT $OUTPUT
    echo initialized!
  else
    echo already initialized!
  fi
  touch $PROG.c
}

function clean { #inte
  for i in `seq 1 $[NVER-1]` #inte
  do
    rm $SUBDIR/$i.c
  done
  echo 1 > $VERFIL
  #they might not exist
  rm $PROG $PROG.c $INPUT $OUTPUT 2> /dev/null
  touch $PROG.c $INPUT $OUTPUT
}

#check for subdir, version, each source, i/oput file, main source
function checkintegrity {
  INTEGRAL=0
  if ! [ -e $SUBDIR ]; then
    echo not initialized
  elif ! [ -e $VERFIL ]; then
    echo missing version indicator
  else
    NVER=$(cat $VERFIL)
    for i in `seq 1 $[NVER-1]`
    do
      if ! [ -e $SUBDIR/$i.c ]; then
        INTEGRAL=1
        break
      fi
    done
    if [ 1 == $INTEGRAL ]; then
      INTEGRAL=0
      echo source file $i.c missing
    elif ! [ -e $INPUT ]; then
      echo no input file. structure broken
    elif ! [ -e $OUTPUT ]; then
      echo no output file structure broken
    elif ! [ -e $PROG.c ]; then
      echo no main source file
    else
      INTEGRAL=1
    fi
  fi
}

#doesn't check whether dirname exists
function achieve { #inte
  if [ -z $1 ]; then
    echo ERROR! \'achieve\' must be called with dirname parameter
  else
    mkdir $SUBDIR/$1
    mv $VERFIL $OUTPUT $INPUT $SUBDIR/$1 #inte

    for i in `seq 1 $[NVER-1]`
    do
      mv $SUBDIR/$i.c $SUBDIR/$1 #inte
    done
    touch $VERFIL $INPUT $OUTPUT
    echo 1 > $VERFIL
  fi
}

function usage {
  echo ' '
  echo "usage: sd <command> | sd --help"
  echo "init | remove                   :before integrity check"
  echo "  init-initialize, remove-terminate"
  echo ' '
  echo "ve | co | te | st               :with source of a version"
  echo "  ve-version, co-compile"
  echo "  te-test with IO files, hide compile warning messages"
  echo "  st-show status of current source compared with latest"
  echo ' '
  echo "ne | re | cp [<n>]              :with versions of source"
  echo "  ne-to next version, re-return to latest version"
  echo "  cp <n>-copy source of n'th version, or the latest if not specified"
  echo ' '
  echo "new | view | go <name>          :with various achieves"
  echo "  new-start new achieve, interactively query name for saving archieve"
  echo "  view-view all saved achieves"
  echo "  go-go to another achieve of given name, current version must be 1"
  echo ' '
  echo "stdin [file] | stdout [file]    :only at the start of new archieve"
  echo "  set the i/oput file .. named as 'file'"
  echo "  must be called at ver. 1"
  echo "  if file name not specified, opens vim to edit them automatically"
  echo ' '
  echo "--help                          :when you don't know what to do"
  echo "  --help-print this manual"
  echo ' '
}

#if [ -z "$1" ]; then #check if $1 is null string
if [ $# -eq 0 ]; then #check if number of argument is 0
  usage
  exit
fi

if [ "--help" == "$1" ]; then
  usage
  exit
elif [ "init" == "$1" ]; then
  init #inte
  exit
elif [ "remove" == "$1" ]; then
  rm -rf $SUBDIR .tmpout 2> /dev/null
  echo all removed
  exit
fi

checkintegrity
if [ 0 == $INTEGRAL ]; then
  echo STRUCTURE DEAMAGED!
  exit
fi


#print current version
if [ "ve" == "$1" ]; then
  echo on source ver. $NVER #inte

#compile the code
elif [ "co" == "$1" ]; then
  compile

#test the code
elif [ "te" == "$1" ]; then
  if [ 1 == $(compile "quit") ]; then
    echo compile error!
  else
    cntest
  fi

#state of current code
elif [ "st" == "$1" ]; then
  lines=$(echolines $PROG.c) #inte
  bytes=$(echobytes $PROG.c) #inte
  if [ 1 != $NVER ]; then #inte
    LPROG=$SUBDIR/$[NVER-1] #inte
    llines=$(echolines $LPROG.c) #inte
    lbytes=$(echobytes $LPROG.c) #inte
    echo current source is $bytes\($[bytes-lbytes]\) bytes, in $lines\($[lines-llines]\) lines
  else
    echo current source is $bytes bytes, in $lines lines
  fi

#set to next version
elif [ "ne" == "$1" ]; then
  if ! [ -e $PROG ]; then
    echo test the code first
  else
    if [ 1 == $(cntest "quiet") ]; then
      echo test failed! check it again
    else
      cp $PROG.c $SUBDIR/$NVER.c #inte #inte
      NVER=$[NVER+1] #inte
      echo $NVER > $VERFIL #inte
      echo on source ver. $NVER #inte
      if [ -e $PROG ]; then
        rm $PROG
      fi
    fi
  fi

#resset to the lastest version
elif [ "re" == "$1" ]; then
  if [ $NVER ==  1 ]; then #inte
    echo no prior version
  else
    NVER=$[NVER-1] #inte
    mv $SUBDIR/$NVER.c $PROG.c #inte #inte
    echo $NVER > $VERFIL #inte
    echo on source ver. $NVER #inte
  fi

#copy the 'n' version file
elif [ "cp" == "$1" ]; then
  cpver=0
  #not number, the latest
  if [ -z "$2" ]; then
    cpver=$[NVER-1] #inte

  #number
  elif ! [[ $2 =~ $REXNUM ]]; then
    echo need version number
  elif [ $2 -ge $NVER ]; then #inte
    echo incompatible version
  else
    cpver=$2
  fi

  if [ cpver != 0 ]; then
    cp $SUBDIR/$cpver.c $PROG.c
    echo copied ver. $cpver
  fi

#TODO match y Y Yes YES ..
#TODO vaild filename check is week
#new problem
elif [ "new" == "$1" ]; then
  if [ 1 == $NVER ]; then #inte
    echo you\'ve done nothing!
  else
    echo make achieve for this problem \[Y/N/C\]?
    valid=0
    while [ $valid == 0 ]; do
      read ans
      if [ "$ans" == "c" ]; then
        valid=1
      elif [ "$ans" == "n" ]; then
        clean
        valid=1
      elif [ "$ans" == "y" ]; then
        name=""
        echo what is name for this achieve?
        while [ -z $name ] || [ -e $name ]; do
          read name
          if [ -z $name ]; then
            echo type something!;
          elif [ -e $name ]; then
            echo exist!;
          fi
        done
        achieve $name #inte
        echo you are on new achieve, ver. 1
        valid=1
      else
        echo please, answer in \[Y/N\]
      fi
    done
  fi

#view the archieves
elif [ "view" == "$1" ]; then
  viewachieves

#go to specific archieve
elif [ "go" == "$1" ]; then
  if [ 1 != $NVER ]; then #inte
    echo save current achieves
  elif [ -z "$2" ]; then
    echo specify the name of achieve
  elif ! [ -e $SUBDIR/$2 ]; then
    echo check the name again
  else
    #reset $NVER //it's alreay on version 1
    mv $SUBDIR/$2/* $SUBDIR/$2/.* $SUBDIR
    NVER=$(cat $VERFIL)
    mv $SUBDIR/$[NVER-1].c $PROG.c # achieves are always version over 1
    echo achieve \"$2\", coping ver. $[NVER-1]
  fi

#set input file
elif [ "stdin" == "$1" ]; then
  if [ 1 != $NVER ]; then
    echo you can't call stdin if it's not the start of a achieve
  elif [ -z "$2" ]; then
    # no automatic newline at eof
    vim $INPUT -c 'set noeol' -c 'set binary'
  else
    if [ ! -e $2 ]; then
      echo file $2 does not exist!
    else
      cp $2 $OUTPUT
    fi
  fi

elif [ "stdout" == "$1" ]; then
  if [ 1 != $NVER ]; then
    echo you can't call stdout if it's not the start of a achieve
  elif [ -z "$2" ]; then
    # no automatic newline at eof
    vim $OUTPUT -c 'set noeol' -c 'set binary'
  else
    if [ ! -e $2 ]; then
      echo file $2 does not exist!
    else
      cp $2 $OUTPUT
    fi
  fi

#wrong usage
else
  usage
  exit
fi
